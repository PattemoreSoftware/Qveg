# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Qveg
                                 A QGIS plugin
 Loads Queensland Vegetation Management (QVM) map data from the Queensland government feature server based on a property (lot plan) search.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-05-06
        copyright            : (C) 2020 by Otto and Gary Pattemore
        email                : g .dot. pattemore .at. gmail .dot. com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This work is licensed under the Creative Commons Attribution 4.0      *
 *   International License. To view a copy of this license,                *
 *   visit http://creativecommons.org/licenses/by/4.0/ or                  *
 *   send a letter to Creative Commons,                                    *
 *   PO Box 1866, Mountain View, CA 94042, USA.                            *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Otto and Gary Pattemore'
__date__ = '2020-05-06'
__copyright__ = '(C) 2020 by Otto and Gary Pattemore'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import *
from qgis.utils import iface
import re
import os
import processing
from PyQt5.QtGui import QIcon
import time
import datetime
import json
from PyQt5.QtWidgets import QMessageBox
#
def resolve(name, basepath=None):
    if not basepath:
      basepath = os.path.dirname(os.path.realpath(__file__))
    return os.path.join(basepath, name)
class QextentAlgorithm(QgsProcessingAlgorithm):
    #INPUT = 'INPUT'
    OUTPUTDIR = 'OUTPUTDIR'
    LOADTENURE = "LOADTENURE"
    LOADSUPPORTINGMAP = "LOADSUPPORTINGMAP"
    LOADPRECLEARMAP = "LOADPRECLEARMAP"
    LOADRVM = "LOADRVM"
    LOADPMAV = "LOADPMAV"
    LOADESSHAB = "LOADESSHAB"
    LOADWETLANDS = "LOADWETLANDS"
    LOADVMWATER8 = "LOADVMWATER8"
    LOADVMWATER7 = "LOADVMWATER7"
    LOADPPTM = "LOADPPTM"
    LOADKPA = "LOADKPA"
    LOADKHA = "LOADKHA"
    LOADKHAL = "LOADKHAL"
    LOADKRA = "LOADKRA"
    def initAlgorithm(self, config):
        #self.addParameter(
        #    QgsProcessingParameterNumber(
        #        self.INPUT,
        #        self.tr('Set a maximum object number to download')
        #    )
        #)
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.LOADTENURE,
                self.tr('Tenure'),
                False
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.LOADSUPPORTINGMAP,
                self.tr('Regional ecosystem map, supporting the RVM map (VMA s20A)'),
                False
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.LOADPRECLEARMAP,
                self.tr('Pre-clear regional ecosystem map, using RE classes of VMA s22LA-LC (used for VM purposes, eg. determining exchange areas)'),
                False
            )
        )
        self.addParameter(
            QgsProcessingParameterFolderDestination(
                self.OUTPUTDIR,
                self.tr("Directory to save output files")
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.LOADRVM,
                self.tr('RVM map (Regulated Vegetation Management map, VMA s20A)'),
                False
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.LOADPMAV,
                self.tr('PMAV (Property Map of Assessable Vegetation, VMA s20AK)'),
                False
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.LOADESSHAB,
                self.tr('Essential Habitat (VMA s20AC)'),
                False
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.LOADWETLANDS,
                self.tr('Wetlands (VMA, s20AA)'),
                False
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.LOADVMWATER8,
                self.tr('VM Water courses 1:25000 SEQ (VMA s20AB)'),
                False
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.LOADVMWATER7,
                self.tr('VM Water courses 1:100,000 or 1:250,000 (VMA s20AB)'),
                False
            )
        )           
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.LOADPPTM,
                self.tr('Protected Plant Trigger Map'),
                False
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.LOADKPA,
                self.tr('Koala Priority Area'),
                False
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.LOADKHA,
                self.tr('Core Koala Habitat Area'),
                False
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.LOADKHAL,
                self.tr('Locally refined Koala Habitat Area - used by local govt'),
                False
            )
        )
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.LOADKRA,
                self.tr('Koala Restoration Area'),
                False
            )
        )
    def GetGEOJSON(self,URL,context,feedback):
        #This method of server access avoids firewall problems
        params = {
            'URL' : URL,
            'OUTPUT' : "TEMPORARY_OUTPUT"
        }
        tempLayer = processing.run(
            'native:filedownloader',
            params,
            is_child_algorithm=True,
            context=context,
            feedback=feedback)["OUTPUT"]
        if feedback.isCanceled():
            return None
        file = open(tempLayer)
        return_string = file.read()
        file.close()
        return return_string
    def BuildQuery(self,post,context,feedback):
        # 
        # Mandatory query parameters
        service1 = post.get('service1', '')
        service2 = post.get('service2', '')
        serviceNumber = post.get('serviceNumber', '')
        #
        # Optional query parameters with defaults
        f = post.get('f', 'json')
        serviceType = post.get('serviceType', "MapServer/")
        returnCountOnly = post.get('returnCountOnly', "false")
        returnGeometry = post.get('returnGeometry',"true")
        returnIdsOnly = post.get('returnIdsOnly', "false")
        outFields = post.get('outFields', '*')
        outSR = post.get('outSR', '7844')
        inSR = post.get('inSR', '7844')
        geometryType = post.get('geometryType', "esriGeometryEnvelope")
        #
        # Optional query parameters with empty string defaults
        where = post.get('where', '')
        objectIds = post.get('objectIds', '')
        geometry = post.get('geometry', '')
        # Build
        baseURL = "https://gisservices.information.qld.gov.au/arcgis/rest/"
        serviceURL = "services/"+service1+service2+serviceType
        whereURL = serviceNumber+"/query?where="+where+"&objectIds="+objectIds+"&time="
        geomURL = "&geometry="+geometry+"&geometryType="+geometryType+"&inSR="+inSR+"&spatialRel=esriSpatialRelIntersects&distance=&units=esriSRUnit_Meter&relationParam="
        out1URL = "&outFields="+outFields+"&returnGeometry="+returnGeometry+"&maxAllowableOffset=&geometryPrecision=&outSR="+outSR+"&having=&gdbVersion=&historicMoment=&returnDistinctValues=false"
        out2URL = "&returnIdsOnly="+returnIdsOnly+"&returnCountOnly="+returnCountOnly+"&returnExtentOnly=false&orderByFields=&groupByFieldsForStatistics=&outStatistics="
        out3URL = "&returnZ=false&returnM=false&multipatchOption=xyFootprint&resultOffset=&resultRecordCount=&returnTrueCurves=false&returnExceededLimitFeatures=false"
        out4URL = "&quantizationParameters=&returnCentroid=false&sqlFormat=none&resultType=&featureEncoding=esriDefault&f="+f
        queryURL = baseURL+serviceURL+whereURL+geomURL+out1URL+out2URL+out3URL+out4URL
        # --following line to be deleted
        print(queryURL)
        return queryURL
    def LoadNaturalResourceLoader(self,post,layerInfo,context,feedback,RC):
        #list layerInfo
        standardCRS = layerInfo['standardCRS']
        canvasCRS = layerInfo['canvasCRS']
        layername = layerInfo['layername']
        layerstyle = layerInfo['layerstyle']
        outputDIR = layerInfo['outputDIR']
        geomtype = layerInfo['geomtype']
        gpkg_basename = layerInfo['gpkg_basename']
        service1 = post['service1']
        #
        standardCRSshort = standardCRS[len("EPSG:"):]
        post.update(dict(outSR = standardCRSshort))
        canvasCRSshort = canvasCRS[len("EPSG:"):]
        post.update(dict(inSR = canvasCRSshort))
        # make empty vector layer
        VMlayer = QgsVectorLayer(geomtype, layername, "memory")
        if not VMlayer.isValid():
                feedback.reportError("Layer failed to load! [code A1]", True)
                return 0
        #
        #Get data
        post.update(dict(   returnCountOnly = "true",
                            f = 'geojson',
                            geometry = layerInfo['extent']
                            ))
        #print(self.BuildQuery(post))
        queryResult = self.GetGEOJSON(self.BuildQuery(post,context,feedback),context,feedback)
        if queryResult == None:
            feedback.reportError("Problem communicating with server [code A1.2]", True)
            return -1
        if RC == 0:
            objectCount = json.loads(queryResult)["count"]
            feedback.setProgressText("Object count = "+str(objectCount))
            return objectCount
        else:
            post.update(dict(   returnCountOnly = "false",
                                returnIdsOnly = "true",
                                f = 'json',
                                objectIds = ''
                                ))
            objects = self.GetGEOJSON(self.BuildQuery(post,context,feedback),context,feedback)
            if objects == None:
                feedback.reportError("Problem communicating with server [code A1.3]", True)
                return -1
            post.update(dict(geometry = ''))
            objectID_list = json.loads(objects)["objectIds"]
            if objectID_list == None:
                feedback.setProgressText("No objects to retrieve...skipping")
                return 0
            objectCount = len(objectID_list)
            feedback.setProgressText("Getting "+str(objectCount)+" objects")
            #
            #Get 1000 features at a time - server limit is 2000 per query
            bundleSize = 1000
            position=0
            post.update(dict(   f = 'geojson',
                                returnIdsOnly = "false"
                                ))
            while position*bundleSize < objectCount:
                sublist = objectID_list[position*bundleSize:position * bundleSize + (bundleSize-1)]
                sublist = ",".join(map(str,sublist))
                post.update(dict(objectIds = sublist))
                sublistQueryResult = self.GetGEOJSON(self.BuildQuery(post,context,feedback),context,feedback)
                if sublistQueryResult == None:
                    feedback.reportError("Problem communicating with server [code A1.4]", True)
                    return -1
                tempLayer = QgsVectorLayer(sublistQueryResult, layername, "ogr")
                #
                #Check if valid geometry is returned
                if tempLayer.featureCount() > 0:
                    #Buffer layer to clean-up inconsistencies in returned vector info -- uses buffer distance = 0
                    if QgsWkbTypes.geometryDisplayString(tempLayer.geometryType()) == "Polygon":
                        params = {
                            'INPUT' : tempLayer,
                            'DISTANCE' : 0,
                            'OUTPUT' : "memory:"
                        }
                        tempLayer = processing.run(
                            'native:buffer', 
                            params,
                            #is_child_algorithm=True,
                            context=context,
                            feedback=feedback)["OUTPUT"]
                        if feedback.isCanceled():
                            return 0
                    #
                    # Merging layer with Master copy if the clipped layer still has features
                    if tempLayer.featureCount() > 0:
                        params = {
                            'LAYERS' : [tempLayer,VMlayer],
                            'OUTPUT' : "memory:"
                        }
                        VMlayer = processing.run(
                            'native:mergevectorlayers', 
                            params,
                            #is_child_algorithm=True,
                            context=context,
                            feedback=feedback)["OUTPUT"]
                        if feedback.isCanceled():
                            return 0
                feedback.setProgress(25+round(position*bundleSize/objectCount*50))
                position = position + 1
                if position*bundleSize < objectCount: feedback.setProgressText("Got "+str(position*bundleSize)+" of "+str(objectCount)+" polygons")
            #Write layer to shape file and reload layer from shapefile
            TimeString = str(datetime.datetime.now()).replace(':','-').replace(':','-').replace('.','-').replace(' ','-')
            # set style
            #VMlayer.loadNamedStyle(resolve(layerInfo['layerstyle']))
            #Save as GeoPackage
            QgsVectorFileWriter.writeAsVectorFormat(VMlayer,outputDIR+'/'+layername+'_'+TimeString+".gpkg",'utf-8',QgsCoordinateReferenceSystem(standardCRS))
            #Save as shapefile 
            #QgsVectorFileWriter.writeAsVectorFormat(VMlayer,outputDIR+'/'+layername+'_'+TimeString+".shp",'utf-8',QgsCoordinateReferenceSystem(standardCRS),driverName="ESRI Shapefile")
            #
            # Reload layer
            VMlayer = QgsVectorLayer(outputDIR+'/'+layername+'_'+TimeString+".gpkg",layername,"ogr")
            if not VMlayer.isValid():
                    feedback.reportError("Failed to load layer "+layername, True)
                    return 0
            #
            VMlayer.loadNamedStyle(resolve(layerInfo['layerstyle']))
            #write style to geopackage
            VMlayer.saveStyleToDatabase(name="Qveg-default", description=layerInfo['layerstyle'], useAsDefault=True, uiFileContent="")
            #
            #Add layer to canvas
            project = QgsProject.instance()
            project.addMapLayer(VMlayer, False)
            layerTree = iface.layerTreeCanvasBridge().rootGroup()
            layerTree.insertChildNode(1, QgsLayerTreeLayer(VMlayer))
            #VMlayer.triggerRepaint()
            feedback.setProgress(90)
            return 0
    def processAlgorithm(self, parameters, context, feedback):
        # Set the standard CRS to GDA2020 (EPSG:7844)
        standardCRS = "EPSG:7844"
        #  
        loadTenure = self.parameterAsBool(parameters,self.LOADTENURE,context)
        loadSupportingMap = self.parameterAsBool(parameters,self.LOADSUPPORTINGMAP,context)
        loadPreClearMap = self.parameterAsBool(parameters,self.LOADPRECLEARMAP,context)
        loadRVM = self.parameterAsBool(parameters,self.LOADRVM,context)
        loadPMAV = self.parameterAsBool(parameters,self.LOADPMAV,context)
        loadEssHab = self.parameterAsBool(parameters,self.LOADESSHAB,context)
        loadPPTM = self.parameterAsBool(parameters,self.LOADPPTM,context)
        loadWetlands = self.parameterAsBool(parameters,self.LOADWETLANDS,context)
        loadVMWater8 = self.parameterAsBool(parameters,self.LOADVMWATER8,context)
        loadVMWater7 = self.parameterAsBool(parameters,self.LOADVMWATER7,context)
        loadKoalaPA = self.parameterAsBool(parameters,self.LOADKPA,context)
        loadKoalaHA = self.parameterAsBool(parameters,self.LOADKHA,context)
        loadKoalaRA = self.parameterAsBool(parameters,self.LOADKRA,context)
        loadKoalaHAL = self.parameterAsBool(parameters,self.LOADKHAL,context)
        outputDIR = self.parameterAsFileOutput(parameters,self.OUTPUTDIR,context)
        feedback.setProgress(1)
        # The following lines workaround an apparent QGIS bug where a temporary directory isn't actually made.
        try:
            os.mkdir(outputDIR)
        except FileExistsError as e:
            pass
        #
        feedback.setProgress(5)
        #
        # Calculate area of extent
        project = QgsProject.instance()
        canvas = iface.mapCanvas()
        canvasExtent = canvas.extent()
        tempV = QgsGeometry().fromRect(canvasExtent)
        measure = QgsDistanceArea()
        tc= project.transformContext()
        canvasCRS = QgsCoordinateReferenceSystem(canvas.mapSettings().destinationCrs().authid())
        measure.setSourceCrs(canvasCRS,tc)
        measure.setEllipsoid(project.ellipsoid())
        area = measure.measureArea(tempV)
        # Exit if too large
        if area/10000 > 10000000:
            feedback.reportError("Extent is too large ("+str(round(area/10000))+" ha) - exiting...", True)
            return {}
        #
        #Convert canvas extent to standard CRS
        xform = QgsCoordinateTransform(canvasCRS, QgsCoordinateReferenceSystem(standardCRS), project)
        canvasExtent = xform.transform(canvasExtent)
        # Get canvas CRS in plain english - actually, this is only used for server query and should be in standardCRS
        #NEEDS RENAMING
        #canvasCRS = QgsCoordinateReferenceSystem(canvas.mapSettings().destinationCrs()).authid()
        canvasCRS = standardCRS
        #
        # Build geometry query string
        xmin = str(canvasExtent.xMinimum())
        ymin = str(canvasExtent.yMinimum())
        xmax = str(canvasExtent.xMaximum())
        ymax = str(canvasExtent.yMaximum())
        ExtentString = xmin+","+ymin+","+xmax+","+ymax
        print(ExtentString)
        TimeString = str(datetime.datetime.now()).replace(':','-').replace(':','-').replace('.','-').replace(' ','-')
        # Initialise dictionaries
        post = {}
        layerInfo = dict(   outputDIR = outputDIR,
                            standardCRS = standardCRS,
                            canvasCRS = canvasCRS,
                            gpkg_basename = 'Qveg-ExtentSearch_'+TimeString,
                            extent = ExtentString
                            )
        # Set object count warning value
        MaxObjects = 20000
        GrandTotal = 0
        #QT messagebox return values
        no = 65536
        yes = 16384
        # set to first return count of object only 
        #
        for RC in range (2): # RC= Return Count --- if RC=0 loop will count the required objects only -- to test if query is reasonable. 
            if GrandTotal > MaxObjects:
                response = QMessageBox.question(None, "Large download warning", "The chosen extent and layers have resulted in a request for "+str(GrandTotal)+" objects.\n\n"+
                "As a rough guide 100,000 objects may take 10 minutes on faster connections but a few hours on slower connections.\n\n"+
                "Recommendation: try a smaller extent or download the dataset directly from http://qldspatial.information.qld.gov.au \n\n"+
                "Do you want to proceed this the current request ?")
                if response == no: 
                    feedback.reportError("Request terminated by user", True)
                    return {}
            #Load Natural Resource layers
            if loadTenure:
                feedback.setProgressText("Working on tenure map...")
                post.update(dict(   service1 = "PlanningCadastre/", 
                                    service2 = "LandParcelPropertyFramework/",
                                    serviceNumber = str(13)
                                    ))
                layerInfo.update(dict(  layername = "Tenure",
                                        layerstyle = "LayerStyles/QldPropertyTenure.qml",
                                        geomtype = "MultiPolygon"
                                        ))
                value = self.LoadNaturalResourceLoader(post,layerInfo,context,feedback,RC)
                if value < 0:
                    return {}
                else:
                    GrandTotal = GrandTotal + value 
            # Update server details
            post.update(dict(   service1 = "Biota/", 
                                service2 = "VegetationManagement/"
                                ))
            if loadSupportingMap:
                feedback.setProgressText("Working on regional ecosystem map...")
                post.update(dict(serviceNumber = str(134)))
                layerInfo.update(dict(  layername = "Regional ecosystem map (regulated)",
                                        layerstyle = "LayerStyles/SupportingMap.qml",
                                        geomtype = "MultiPolygon"
                                        ))
                value = self.LoadNaturalResourceLoader(post,layerInfo,context,feedback,RC)
                if value < 0:
                    return {}
                else:
                    GrandTotal = GrandTotal + value 
            if loadPreClearMap:
                feedback.setProgressText("Getting pre-clear regional ecosystem map...")
                post.update(dict(serviceNumber = str(15)))
                layerInfo.update(dict(  layername = "Pre-clear RE map (VM edition)",
                                        layerstyle = "LayerStyles/PreClearMap.qml",
                                        geomtype = "MultiPolygon"
                                        ))
                value = self.LoadNaturalResourceLoader(post,layerInfo,context,feedback,RC)
                if value < 0:
                    return {}
                else:
                    GrandTotal = GrandTotal + value 
            if loadRVM:
                feedback.setProgressText("Working on RVM...")
                post.update(dict(serviceNumber = str(109)))
                layerInfo.update(dict(  layername = "RVM",
                                        layerstyle = "LayerStyles/RVM.qml",
                                        geomtype = "MultiPolygon"
                                        ))
                value = self.LoadNaturalResourceLoader(post,layerInfo,context,feedback,RC)
                if value < 0:
                    return {}
                else:
                    GrandTotal = GrandTotal + value 
            if loadPMAV:
                feedback.setProgressText("Working on PMAV...")
                post.update(dict(serviceNumber = str(146)))
                layerInfo.update(dict(  layername = "PMAV",
                                        layerstyle = "LayerStyles/PMAV.qml",
                                        geomtype = "MultiPolygon"
                                        ))
                value = self.LoadNaturalResourceLoader(post,layerInfo,context,feedback,RC)
                if value < 0:
                    return {}
                else:
                    GrandTotal = GrandTotal + value 
            if loadEssHab:
                feedback.setProgressText("Working on Essential Habitat map...")
                post.update(dict(serviceNumber = str(5)))
                layerInfo.update(dict(  layername = "Essential Habitat",
                                        layerstyle = "LayerStyles/EssentialHabitat.qml",
                                        geomtype = "MultiPolygon"
                                        ))
                value = self.LoadNaturalResourceLoader(post,layerInfo,context,feedback,RC)
                if value < 0:
                    return {}
                else:
                    GrandTotal = GrandTotal + value 
            if loadWetlands:
                feedback.setProgressText("Working on Wetlands map...")
                post.update(dict(serviceNumber = str(4)))
                layerInfo.update(dict(  layername = "Wetlands",
                                        layerstyle = "LayerStyles/Wetlands.qml",
                                        geomtype = "MultiPolygon"
                                        ))
                value = self.LoadNaturalResourceLoader(post,layerInfo,context,feedback,RC)
                if value < 0:
                    return {}
                else:
                    GrandTotal = GrandTotal + value 
            if loadVMWater8:
                feedback.setProgressText("Working on 1:25000 (SEQ) Watercourse map...")
                post.update(dict(serviceNumber = str(8)))
                layerInfo.update(dict(  layername = "VM Watercourses-SEQ)",
                                        layerstyle = "LayerStyles/VMWaterCourse.qml",
                                        geomtype = "MultiLineString"
                                        ))
                value = self.LoadNaturalResourceLoader(post,layerInfo,context,feedback,RC)
                if value < 0:
                    return {}
                else:
                    GrandTotal = GrandTotal + value 
            if loadVMWater7:
                feedback.setProgressText("Working on Qld Watercourse map...")
                post.update(dict(serviceNumber = str(7)))
                layerInfo.update(dict(  layername = "VM Watercourses QLD",
                                        layerstyle = "LayerStyles/VMWaterCourse.qml",
                                        geomtype = "MultiLineString"
                                        ))
                value = self.LoadNaturalResourceLoader(post,layerInfo,context,feedback,RC)
                if value < 0:
                    return {}
                else:
                    GrandTotal = GrandTotal + value 
            if loadPPTM:
                feedback.setProgressText("Working on Protected Plant Trigger Map...")
                post.update(dict(serviceNumber = str(201)))
                layerInfo.update(dict(  layername = "Protected Plant Trigger Map",
                                        layerstyle = "LayerStyles/PPTM.qml",
                                        geomtype = "MultiPolygon"
                                        ))
                value = self.LoadNaturalResourceLoader(post,layerInfo,context,feedback,RC)
                if value < 0:
                    return {}
                else:
                    GrandTotal = GrandTotal + value 
            # Update server details
            post.update(dict(   service1 = "Environment/", 
                                service2 = "KoalaPlan/"
                                ))
            if loadKoalaPA:
                feedback.setProgressText("Working on Koala Priority Area...")
                post.update(dict(serviceNumber = str(1)))
                layerInfo.update(dict(  layername = "Koala Priority Area",
                                        layerstyle = "LayerStyles/KoalaPriorityArea.qml",
                                        geomtype = "MultiPolygon"
                                        ))
                value = self.LoadNaturalResourceLoader(post,layerInfo,context,feedback,RC)
                if value < 0:
                    return {}
                else:
                    GrandTotal = GrandTotal + value 
            if loadKoalaHA:
                feedback.setProgressText("Working on Koala Habitat Area-core...")
                post.update(dict(serviceNumber = str(3)))
                layerInfo.update(dict(  layername = "Koala Habitat Area-core",
                                        layerstyle = "LayerStyles/KoalaHabitatArea-core.qml",
                                        geomtype = "MultiPolygon"
                                        ))
                value = self.LoadNaturalResourceLoader(post,layerInfo,context,feedback,RC)
                if value < 0:
                    return {}
                else:
                    GrandTotal = GrandTotal + value 
            if loadKoalaRA:
                feedback.setProgressText("Working on Koala Restoration Area...")
                post.update(dict(serviceNumber = str(6)))
                layerInfo.update(dict(  layername = "Koala Restoration Area",
                                        layerstyle = "LayerStyles/KoalaHabitatRestorationArea.qml",
                                        geomtype = "MultiPolygon"
                                        ))
                value = self.LoadNaturalResourceLoader(post,layerInfo,context,feedback,RC)
                if value < 0:
                    return {}
                else:
                    GrandTotal = GrandTotal + value 
            if loadKoalaHAL:
                feedback.setProgressText("Working on Koala Habitat Area-locally refined...")
                post.update(dict(serviceNumber = str(5)))
                layerInfo.update(dict(  layername = "Koala Habitat Area-locally refined",
                                        layerstyle = "LayerStyles/KoalaHabitatArea-LocallyRefined.qml",
                                        geomtype = "MultiPolygon"
                                        ))
                value = self.LoadNaturalResourceLoader(post,layerInfo,context,feedback,RC)
                if value < 0:
                    return {}
                else:
                    GrandTotal = GrandTotal + value 
            #
        #
        #
        feedback.setProgress(100)
        #
        return {}
    
    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Search by extent'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Vegetation Management'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return QextentAlgorithm()
    
    def icon(self):
        return QIcon(resolve("SearchByExtent.png"))
    
    def flags(self):
        return super().flags() | QgsProcessingAlgorithm.FlagNoThreading
    #